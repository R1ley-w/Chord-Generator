MARKOV CHAIN FOR JAZZ PROGRESSION 

class MarkovChain:
    properties:
        order: integer (e.g., 2 for 2nd-order)
        transitions: dictionary of dictionaries
        chord_vocab: list of unique chords
        start_states: list of common starting sequences
        
    methods:
        train(progressions)
        predict_next(previous_chords, temperature=1.0)
        get_possible_next(previous_chords)
        weighted_choice(probabilities, temperature)

class JazzChord:
    properties:
        root: string (e.g., "C", "F#")
        quality: string (e.g., "maj7", "m7", "7", "m7b5")
        extensions: list (e.g., ["9", "#11"])
        full_symbol: string (e.g., "Cmaj7#11")
        
    methods:
        normalize()  # Convert to standard representation
        simplify()   # Remove extensions for basic analysis

function preprocess_jazz_standards(dataset):
    progressions = []
    
    for song in dataset:
        # Convert raw chord symbols to standardized format
        normalized_chords = []
        
        for chord in song.chord_progression:
            jazz_chord = parse_chord_symbol(chord.raw_symbol)
            normalized_chords.append(jazz_chord.normalize())
        
        # Handle different representations of same chord
        simplified_progression = [chord.simplify() for chord in normalized_chords]
        progressions.append(simplified_progression)
    
    return progressions

function parse_chord_symbol(raw_symbol):
    # Handle various chord notation styles
    if raw_symbol contains "∆" or "ma7" or "maj7":
        quality = "maj7"
    elif raw_symbol contains "mi7" or "-7":
        quality = "m7" 
    elif raw_symbol contains "ø" or "m7b5":
        quality = "m7b5"
    elif raw_symbol contains "o" or "dim7":
        quality = "dim7"
    else if raw_symbol contains "7":
        quality = "7"
    else:
        quality = "maj7"  # default assumption
    
    # Extract root note and extensions
    root = extract_root_note(raw_symbol)
    extensions = extract_extensions(raw_symbol)
    
    return JazzChord(root, quality, extensions)


function train_markov_chain(progressions, order=2):
    markov = new MarkovChain(order=order)
    
    # Build vocabulary and count transitions
    for progression in progressions:
        # Add to chord vocabulary
        for chord in progression:
            if chord not in markov.chord_vocab:
                markov.chord_vocab.append(chord)
        
        # Count transitions for each state sequence
        for i from 0 to length(progression) - order:
            state = tuple(progression[i : i + order])  # Previous chords
            next_chord = progression[i + order]        # Following chord
            
            if state not in markov.transitions:
                markov.transitions[state] = {}
            
            if next_chord not in markov.transitions[state]:
                markov.transitions[state][next_chord] = 0
            
            markov.transitions[state][next_chord] += 1
    
    # Convert counts to probabilities
    for state in markov.transitions:
        total_count = sum(markov.transitions[state].values())
        for next_chord in markov.transitions[state]:
            markov.transitions[state][next_chord] /= total_count
    
    # Identify common starting sequences
    markov.start_states = find_common_starters(progressions, order)
    
    return markov

function find_common_starters(progressions, order):
    start_counts = {}
    
    for progression in progressions:
        if len(progression) >= order:
            start_sequence = tuple(progression[0:order])
            start_counts[start_sequence] = start_counts.get(start_sequence, 0) + 1
    
    # Return most common starting sequences
    return sort_by_value(start_counts, descending=True)[0:10]

function filter_by_melody_note(candidates, melody_note):
    # Filter chords to those that contain or harmonize with melody note
    compatible_chords = {}
    
    for chord, probability in candidates.items():
        if is_chord_melody_compatible(chord, melody_note):
            compatible_chords[chord] = probability
    
    # If no compatible chords found, return original candidates
    if compatible_chords is empty:
        return candidates
    
    # Renormalize probabilities
    total = sum(compatible_chords.values())
    for chord in compatible_chords:
        compatible_chords[chord] /= total
    
    return compatible_chords

function is_chord_melody_compatible(chord, melody_note):
    chord_tones = get_chord_tones(chord)
    
    # Check if melody note is a chord tone or available tension
    if melody_note in chord_tones.primary_tones:
        return True
    elif melody_note in chord_tones.available_tensions:
        return True
    else:
        return False  # Melody note clashes with chord

function generate_jazz_progression(markov, melody_notes, length=8, creativity=0.5):
    progression = []
    
    # Convert creativity (0-1) to temperature (0.1-2.0)
    temperature = 0.1 + (creativity * 1.9)
    
    # Choose starting point
    if progression is empty:
        start_state = random_choice(markov.start_states)
        progression.extend(start_state)
    
    # Generate remaining chords
    while len(progression) < length:
        previous_chords = progression
        current_melody_note = get_current_melody_note(melody_notes, len(progression))
        
        next_chord = predict_next_chord(
            markov, 
            previous_chords, 
            temperature=temperature,
            melody_note=current_melody_note
        )
        
        progression.append(next_chord)
    
    # Ensure strong cadence at the end
    progression = force_strong_ending(progression)
    
    return progression

function force_strong_ending(progression):
    # Modify last 2-3 chords to create a satisfying cadence
    if len(progression) >= 2:
        # Common jazz cadences: ii-V-I, V-I, etc.
        if not is_strong_cadence(progression[-2:]):
            # Replace with ii-V-I or V-I
            key = detect_key(progression)
            cadence = generate_cadence(key)
            progression[-len(cadence):] = cadence
    
    return progression


EXAMPLE USAGE

# Main application flow
function main():
    # Load training data
    jazz_standards = load_jazz_standards("weimar_jazz_database.json")
    
    # Preprocess and train
    progressions = preprocess_jazz_standards(jazz_standards)
    markov_model = train_markov_chain(progressions, order=2)
    
    # User interaction
    user_melody = get_user_melody_input()  # e.g., ["C", "E", "G", "B"]
    creativity_level = get_user_creativity_slider()  # 0.0 to 1.0
    
    # Generate progression
    chord_progression = generate_jazz_progression(
        markov_model, 
        user_melody, 
        length=8, 
        creativity=creativity_level
    )
    
    # Output with rhythm
    rhythm_pattern = select_rhythm_style("bossa_nova")
    final_output = apply_rhythm_to_chords(chord_progression, rhythm_pattern)
    
    play_progression(final_output)
    display_chord_chart(chord_progression)